#!/bin/bash
#
# cap2any - capture the screen and output to the specified audio/video format
#
# Written 6-Jul-2015 by Ronald Joe Record <rr at ronrecord dot com>
#
# From https://trac.ffmpeg.org/wiki/Capture/Desktop
#
# Use the avfoundation device:
#
# ffmpeg -f avfoundation -list_devices true -i ""
#
# This will enumerate all the available input devices including
# screens ready to be captured. Once you've figured out the device
# index corresponding to the screen to be captured use:
#
# ffmpeg -f avfoundation -i "<screen device index>:<audio device index>" out.m4v
#
# This will capture the screen from <screen device index> and audio from
# <audio device index> into the output file out.m4v.
#
# Uses the default options for audio/video encoding from my any2any script
#
#    This program works by either linking or copying cap2any to a file
#    which specifies the desired output format by its name.
#    Alternately, the -o command line option can be used to specify
#    the output file format.
#
#    For example, if you want to capture to MP4 then you could
#    create a symbolic link from cap2any to cap2mp4 as follows:
#        ln -s cap2any cap2mp4
#    Similarly, symbolic links (or copies or hard links) could be created to
#    capture to any other audio/video format.
#
#    Naming restricton: cap2[3 lowercase letter output]
#    for a 7 letter name beginning with "cap2". The 3 letter prefix and
#    suffix must also be a filename suffix that ffmpeg recognizes as a valid
#    audio/video format.
#
#    For example, the following are filenames that conform to this restriction:
#        cap2mp4 cap2mpg cap2mkv cap2m4a cap2wmv
#
# Copyright (c) 2015, Ronald Joe Record
# All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# The Software is provided "as is", without warranty of any kind, express or
# implied, including but not limited to the warranties of merchantability,
# fitness for a particular purpose and noninfringement. In no event shall the
# authors or copyright holders be liable for any claim, damages or other
# liability, whether in an action of contract, tort or otherwise, arising from,
# out of or in connection with the Software or the use or other dealings in
# the Software.
#
# AVFoundation supports the following options:
# 
# -list_devices <TRUE|FALSE>
#    If set to true, a list of all available input devices is given showing
#    all device names and indices.
# -video_device_index <INDEX>
#    Specify the video device by its index. Overrides anything given in the
#    input filename.
# -audio_device_index <INDEX>
#    Specify the audio device by its index. Overrides anything given in the
#    input filename.
# -pixel_format <FORMAT>
#    Request the video device to use a specific pixel format. If the specified
#    format is not supported, a list of available formats is given und the first
#    one in this list is used instead. Available pixel formats are: monob,
#    rgb555be, rgb555le, rgb565be, rgb565le, rgb24, bgr24, 0rgb, bgr0, 0bgr,
#    rgb0, bgr48be, uyvy422, yuva444p, yuva444p16le, yuv444p, yuv422p16,
#    yuv422p10, yuv444p10, yuv420p, nv12, yuyv422, gray
# 
# Examples
# 
# Print the list of AVFoundation supported devices and exit:
# $ ffmpeg -f avfoundation -list_devices true -i ""
# 
# Record video from video device 0 and audio from audio device 0 into out.avi:
# $ ffmpeg -f avfoundation -i "0:0" out.avi
# 
# Record video from video device 2 and audio from audio device 1 into out.avi:
# $ ffmpeg -f avfoundation -video_device_index 2 -i ":1" out.avi
# 
# Record video from the system default video device using the pixel format bgr0
# and do not record any audio into out.avi:
# $ ffmpeg -f avfoundation -pixel_format bgr0 -i "default:none" out.avi
# 

# I put the latest experimental ffmpeg in /usr/local/bin but if it's not there
# simply revert to whatever is first in our PATH
FFMPEG=/usr/local/bin/ffmpeg
[ -x ${FFMPEG} ] || FFMPEG=ffmpeg
VIDEO=`${FFMPEG} -f avfoundation -list_devices true -i "" 2>&1 | grep AVFoundation | grep Capture | grep screen | awk ' { print $6 } ' | sed -e "s/\[//" -e "s/\]//"`
AUDIO=`${FFMPEG} -f avfoundation -list_devices true -i "" 2>&1 | grep AVFoundation | grep Built | grep Microphone | awk ' { print $6 } ' | sed -e "s/\[//" -e "s/\]//"`

ME=`basename $0`
if [ "$ME" = "cap2any" ]
then
    SUF="avi"
    DIR="AVI"
else
    SUF="${ME:4:3}"
    DIR=`echo $SUF | tr '[:lower:]' '[:upper:]'`
fi

CODEC=
SIZE=
OVER=
TELL=
USAGE=
ACODEC=
VCODEC=
PRESET=
QSCALE=
RATE=
ASAMPLE=
VSAMPLE=
THREAD=
ITUNES=

usage() {
  printf "\nUsage: $ME [-a audio codec] [-v video codec] [-c codec] [-p preset]"
  printf "\n\t\t[-V screen device index] [-A audio device index]"
  printf "\n\t\t[-o output format (lower case)]"
  printf "\n\t\t[-q scale] [-r rate] [-b audio bitrate] [-z video bitrate]"
  printf "\n\t\t[-s size] [-t threads] [-I] [-d] [-y] [-u]"
  printf "\n\nWhere:\n\t-d indicates tell me what you would do"
  printf "\n\t-o output format specifies the 3 letter lower case output format"
  printf "\n\t-a audio codec specifies the output audio codec"
  printf "\n\t-v video codec specifies the output video codec"
  printf "\n\t-s size specifies the output video size (widthxheight)"
  printf "\n\t-c codec specifies the output codec"
  printf "\n\t-I indicates add the captured file to iTunes"
  printf "\n\t-p preset specifies the ffmpeg preset to use"
  printf "\n\t\t Useful presets:"
  printf "\n\t\t ultrafast superfast veryfast faster fast medium slow"
  printf "\n\t\t slower veryslow. Default preset is 'slow'"
  printf "\n\t-q scale specifies the qscale variable bit rate quality"
  printf "\n\t-r rate specifies the rate for Constant Rate Factor (CRF)"
  printf "\n\t\tencoding. Use \"-r 0\" to disable for formats other than x264"
  printf "\n\t-b bitrate specifies the bitrate (default 128k)"
  printf "\n\t-t threads specifies the number of threads to use"
  printf "\n\t-y indicates overwrite output files without asking"
  printf "\n\t-u displays this usage message\n"
  printf "\nCurrent invocation defaults to:\n\n${FFMPEG} ${CAP} ${OPTS} ${OUT_FILE}\n"
  printf "\nExamples:"
  printf "\n\tThe most common use is capture using the default parameters"
  printf "\n\t\t$ME"
  printf "\n\tSpecify output video size of 640 width by 480 height"
  printf "\n\t\t$ME -s 640x480"
  printf "\n\tSpecify libx264 output video codec and use ipod640 preset"
  printf "\n\t\t$ME -v libx264 -p ipod640"
  printf "\n\tSpecify 512k bitrate and add capture file to iTunes"
  printf "\n\t\t$ME -b 512k -I"
  printf "\n\tSpecify libx264 output video codec and variable bit rate"
  printf "\n\t\t$ME -v libx264 -r 0 -q 3\n"
  exit 1
}

while getopts A:V:o:p:q:r:b:t:s:v:z:a:c:Iydu flag; do
    case $flag in
        A)
            AUDIO="$OPTARG"
            ;;
        V)
            VIDEO="$OPTARG"
            ;;
        a)
            ACODEC="-acodec $OPTARG"
            ;;
        b)
            ASAMPLE="-ab $OPTARG"
            ;;
        o)
            SUF=$OPTARG
            DIR=`echo $SUF | tr '[:lower:]' '[:upper:]'`
            ;;
        z)
            VSAMPLE="-vb $OPTARG"
            ;;
        c)
            CODEC="-codec $OPTARG"
            ;;
        d)
            TELL=1
            ;;
        I)
            inst=`type -p osascript`
            if [ "$inst" ]
            then
                ITUNES=1
            else
                echo "AppleScript is not supported on this platform."
                echo "Unable to automate the installation in iTunes."
            fi
            ;;
        p)
            PRESET="-preset $OPTARG"
            ;;
        q)
            QSCALE="-qscale $OPTARG"
            RATE=
            ;;
        r)
            if [ $OPTARG -eq 0 ]
            then
                RATE=
            else
                RATE="-crf $OPTARG"
            fi
            ;;
        s)
            SIZE="-s $OPTARG"
            ;;
        t)
            THREAD="-threads $OPTARG"
            ;;
        y)
            OVER="-y"
            ;;
        v)
            VCODEC="-vcodec $OPTARG"
            ;;
        u)
            USAGE=1
            ;;
    esac
done
shift $(( OPTIND - 1 ))

OUT_DIR=$HOME/Movies/ScreenCaps/$DIR
[ -d "${OUT_DIR}" ] || mkdir -p "${OUT_DIR}"
OUT_FILE=${OUT_DIR}/capture_$$.$SUF
# Set ffmpeg capture options based upon the desired output format
LOG="-loglevel warning"
# RAT="-framerate 30"
RAT=
EXP="-strict -2"
# PIX="-pix_fmt yuv420p"
PIX=
VSY="-vsync 2"
#
# Set any options specified on the command line - the sed part is just
# removing any leading or trailing spaces.
OPTS=`echo "$OVER $ACODEC $CODEC $SIZE $VCODEC $PRESET $QSCALE $RATE $ASAMPLE $VSAMPLE $THREAD" | sed -e 's/^ *//' -e 's/ *$//'`
CAP="-f avfoundation -i $VIDEO:$AUDIO ${PIX} ${RAT} ${LOG} ${EXP} ${VSY}"
# Check for incompatible ffmpeg arguments
[ "$RATE" ] && [ "$QSCALE" ] && {
    printf "\nCannot specify both constant and variable bit rate values."
    printf "\nCurrent invocation would invoke:\n\n${FFMPEG} ${CAP} ${OPTS} ${OUT_FILE}\n"
    printf "\nExiting.\n"
    exit 1
}

# Display usage message and exit if -u was given on the command line.
# We delay until now in order to gather up all the other command line options.
[ "$USAGE" ] && usage

echo "${FFMPEG} ${CAP} ${OPTS} ${OUT_FILE}"
[ "$TELL" ] || {
    ${FFMPEG} ${CAP} ${OPTS} ${OUT_FILE}

    [ "$ITUNES" ] && {
        # Construct full pathname of output file
        k=`pwd`/"$j"
        echo "Adding $j to iTunes"
        osascript -e "tell application \"iTunes\" to add POSIX file \"$k\""
    }
}
